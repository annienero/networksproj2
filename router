#!/usr/bin/python -u
import argparse, socket, time, json, select, struct, math

#DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class Router:

    routes = None
    updates = None
    relations = None
    sockets = None
    table = {} # forwarding table, map of strings of bits to IPs
    routeAnnouncements = []

    def __init__(self, networks):
        self.routes = {}
        self.updates = {}
        self.relations = {}
        self.sockets = {}
        for relationship in networks:
            network, relation = relationship.split("-")
            self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation
        return

    # forwarding table helpers

    # adds an entry to the forwarding table
    def addTableEntry(self, networkKey, networkInfo):
        if not self.table.has_key(networkKey):
            self.table[networkKey] = []
        self.table[networkKey].append(networkInfo)

    # flat map self.table into a list of (networkKey, networkInfo)
    def flattenTable(self):
        acc = []
        for networkKey in self.table.keys():
            loNetworkInfo = self.table[networkKey]
            loNetworkPairs = map(lambda nwi: (networkKey, nwi), loNetworkInfo)
            acc += loNetworkPairs
        return acc

    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        # TODO called from get_route
        outroutes = []
        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        # TODO called from get_route
        outroutes = []
        return outroutes

    def get_highest_preference(self, routes):
        """ select the route with the shortest AS Path """
        # TODO called from get_route
        outroutes = []
        return outroutes

    def get_self_origin(self, routes):
        """ select self originating routes """
        # TODO called from get_route
        outroutes = []
        return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: EGP > IGP > UNK """
        # TODO called from get_route
        outroutes = []
        return outroutes

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        # TODO called from get_route
	outroutes = []
        return outroutes

    def get_route(self, srcif, daddr):
        """	Select the best route for a given address	"""
        # TODO called from forward
        peer = None
        routes = lookup_routers(daddr)
        # Rules go here
        if routes:
            # 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. EGP > IGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            # TODO
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)
        return self.sockets[peer] if peer else None

    # returns an ip address as a string
    def getRoute(self, dest):
        destAsBin = ipToBin(dest)
        # if one is better, return -1
        # if two is better, return 1
        def compHelp(networkPair1, networkPair2):
            bin1 = resolveForwardingKey(networkPair1[0][0], networkPair1[0][1])
            bin2 = resolveForwardingKey(networkPair2[0][0], networkPair2[0][1])
            np1Match = destAsBin[:len(bin1)] == bin1
            np2Match = destAsBin[:len(bin2)] == bin2
            np1Self = networkPair1[1]['selfOrigin']
            np2Self = networkPair2[1]['selfOrigin']
            np1Local = networkPair1[1]['localpref']
            np2Local = networkPair2[1]['localpref']
            np1AS = len(networkPair1[1]['ASPath'])
            np2AS = len(networkPair2[1]['ASPath'])
            originToNumMap = {'UNK': 1, 'EGP': 2, 'IGP': 3}
            np1Origin = originToNumMap[networkPair1[1]['origin']]
            np2Origin = originToNumMap[networkPair2[1]['origin']]
            src1 = int(ipToBin(networkPair1[1]['ip']), 2)
            src2 = int(ipToBin(networkPair2[1]['ip']), 2)
            if not np2Match:
                return -1
            if not np1Match:
                return 1
            if np1Local > np2Local:
                return -1
            if np1Local < np2Local:
                return 1
            if np1Self == 'True' and np2Self == 'False':
                return -1
            if np2Self == 'True' and np1Self == 'False':
                return 1
            if len(bin1) > len(bin2):
                return 1
            if len(bin2) > len(bin1):
                return -1
            if np1AS > np2AS:
                return 1
            if np2AS > np1AS:
                return -1
            if np1Origin > np2Origin:
                return -1
            if np2Origin > np1Origin:
                return 1
            return src1 - src2

        allTableEntries = self.flattenTable()
        allTableEntries.sort(compHelp)
        bestEntry = allTableEntries[0]
        route = (bestEntry[0][0], bestEntry[0][1], bestEntry[1]['ip'])
        # (network, netmask, ip)
        bin = resolveForwardingKey(route[0], route[1])
        match = destAsBin[:len(bin)] == bin
        if not match:
            return ""
        else:
            return route[2]

    def forward(self, srcif, packet):
        """	Forward a data packet	"""
        route = self.getRoute(packet['dst'])
        if (route == ""):
            return False
        self.sendMessage(self.sockets[route], packet)
        return True

    def coalesce(self):
        """	coalesce any routes that are right next to each other	"""
        # TODO (this is the most difficult task, save until last)
        return False

    def sendMessage(self, socket, packet):
        socket.send(json.dumps(packet))

    def update(self, srcif, packet):
        """	handle update packets	"""
    	# update routing table
    	# first calculate key
        networkInfo = {}
    	network = packet['msg']['network']
    	netmask = packet['msg']['netmask']
        networkInfo['localpref'] = packet['msg']['localpref']
        networkInfo['selfOrigin'] = packet['msg']['selfOrigin']
        networkInfo['ASPath'] = packet['msg']['ASPath']
        networkInfo['origin'] = packet['msg']['origin']
        networkInfo['ip'] = srcif
    	self.addTableEntry((network, netmask), networkInfo)
    	# save a copy of the routing announcement for later
    	self.routeAnnouncements.append(packet)
        # Update received from a customer
        if self.relations[packet['src']] == 'cust':
            # send updates to all other neighbors
            for n in self.relations.keys():
                if n != packet['src']:
                    self.sendMessage(self.sockets[n], formatMessage(n, packet))
        # Update received from a peer or a provider
        else:
            # only send updates to your customers
            for n in self.relations.keys():
                if self.relations[n] == 'cust':
                    self.sendMessage(self.sockets[n], formatMessage(n, packet))
        return True

    def revoke(self, packet):
        """	handle revoke packets	"""
        # TODO called from handle packet
        return True

    def getTable(self):
        message = []
        for pair in self.flattenTable():
            obj = {}
            obj['network'] = pair[0][0]
            obj['netmask'] = pair[0][1]
            obj['peer'] = pair[1]['ip']
            message.append(obj)
        return message

    def dump(self, srcif):
        """	handles dump table requests	"""
        packet = {}
        packet['src'] = srcif[:len(srcif) - 1] + '1'
        packet['dst'] = srcif
        packet['type'] = 'table'
        packet['msg'] = self.getTable()
        self.sendMessage(self.sockets[srcif], packet)
        return True

    def handle_packet(self, srcif, packet): # where packet is the message object, return true on success, false otherwise
        """	dispatches a packet """
    	if packet['type'] == 'update':
    	    return self.update(srcif, packet) # returns success status
    	if packet['type'] == 'revoke':
    	    return self.revoke(packet)
    	if packet['type'] == 'data':
            #if (self.relations[srcif] == 'prov' or self.relations[srcif] == 'peer') and (self.relations[packet['dst']] == 'prov' or self.relations[packet['dst']] == 'peer'):
    	     #  return False
            #else:
            return self.forward(srcif, packet)
    	if packet['type'] == 'no route':
                # TODO what do
    	    return 0
    	if packet['type'] == 'dump':
    	    return self.dump(srcif)
    	if packet['type'] == 'table':
                # TODO what do
    	    return 0
        return False

    def send_error(self, srcif):
        """ Send a no_route error message """
        packet = {
            "src": srcif[:len(srcif) - 1] + '1',
	        "dst": srcif,
	        "type": "no route",
	        "msg": {}
        }
        self.sendMessage(self.sockets[srcif], packet)

    def run(self):
	while True:
	    # socks is the list of sockets that are ready to be read from at this time
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                try:
		    # k is a string representation of the data
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
		    # where sock is a network key (IP address)
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
			    # this means one of our connections matches the one we just read from
                            srcif = sock
		    # parse the json data in k into a python object
                    msg = json.loads(k)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(srcif)
                else:
                    return
        return

def formatMessage(dest, packet): # works for update
    packetSrc = packet['src']
    newPacket = {}
    newPacket['src'] = packetSrc[:len(packetSrc) - 1] + '1'
    newPacket['dst'] = dest
    newPacket['type'] = 'update'
    newPacket['msg'] = packet['msg']
    return newPacket

def ipToBin(ip):
    bin = ""
    for val in map(lambda x: int(x), ip.split('.')):
        for x in range(8):
            if val >= pow(2, 7 - x):
                bin += '1'
                val -= pow(2, 7 - x)
            else:
                bin += '0'
    return bin

def resolveForwardingKey(network, netmask):
    return ipToBin(network)[:ipToBin(netmask).count('1')]

if __name__ == "__main__":
    router = Router(args.networks)
    router.run()
